<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bounce Ladder Game</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    #gameContainer {
      position: relative;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.3);
    }

    #scoreBoard {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffffff;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 8px #000;
      z-index: 10;
    }

    canvas {
      background: #1b1b1b;
      border: 2px solid #00ffff;
      border-radius: 12px;
      display: block;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <div id="scoreBoard">Score: 0</div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let player = {
  x: 400,
  y: 500,
  radius: 20,
  color: 'red',
  vy: -12,
  vx: 0,
  jumpCount: 0,
  maxJumps: 2
};

let platforms = [];
let stars = [];
let keys = {};
let score = 0;
let gameOver = false;

const gravity = 0.5;
const bounceStrength = -12;
const moveSpeed = 5;
const ladderGap = 80;
const platformWidth = 120;
const platformHeight = 10;

for (let i = 0; i < 20; i++) {
  platforms.push({
    x: Math.random() * (canvas.width - platformWidth),
    y: canvas.height - i * ladderGap,
    width: platformWidth,
    height: platformHeight,
    scored: false
  });
}

// Input
document.addEventListener('keydown', (e) => {
  keys[e.code] = true;

  if ((e.code === 'ArrowUp' || e.code === 'Space') && player.jumpCount < player.maxJumps && !gameOver) {
    player.vy = bounceStrength;
    player.jumpCount++;
  }

  if (e.code === 'KeyR' && gameOver) resetGame();
});

document.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});

// Falling stars - every 500ms
setInterval(() => {
  if (!gameOver) {
    stars.push({
      x: Math.random() * (canvas.width - 30),
      y: -30,
      size: 20,
      vy: Math.random() * 2 + 2
    });
  }
}, 500);

function update() {
  if (gameOver) return;

  if (keys['ArrowLeft']) player.vx = -moveSpeed;
  else if (keys['ArrowRight']) player.vx = moveSpeed;
  else player.vx = 0;

  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  // Boundary check
  if (player.x - player.radius < 0) player.x = player.radius;
  if (player.x + player.radius > canvas.width) player.x = canvas.width - player.radius;

  if (player.y + player.radius > canvas.height) {
    player.y = canvas.height - player.radius;
    player.vy = bounceStrength;
    player.jumpCount = 0;
  }

  // Platform collision
  platforms.forEach(p => {
    if (
      player.x + player.radius > p.x &&
      player.x - player.radius < p.x + p.width &&
      player.y + player.radius > p.y &&
      player.y + player.radius < p.y + p.height &&
      player.vy > 0
    ) {
      player.y = p.y - player.radius;
      player.vy = bounceStrength;
      player.jumpCount = 0;

      if (!p.scored) {
        score++;
        p.scored = true;
        document.getElementById('scoreBoard').innerText = `Score: ${score}`;
      }
    }
  });

  // Scroll up
  if (player.y < canvas.height / 2) {
    const offset = canvas.height / 2 - player.y;
    player.y = canvas.height / 2;
    platforms.forEach(p => p.y += offset);
    stars.forEach(s => s.y += offset);

    if (platforms[0].y > canvas.height) {
      platforms.shift();
      platforms.push({
        x: Math.random() * (canvas.width - platformWidth),
        y: -ladderGap,
        width: platformWidth,
        height: platformHeight,
        scored: false
      });
    }
  }

  stars.forEach(s => s.y += s.vy);
  stars = stars.filter(s => s.y < canvas.height + 30);

  // Collision with stars
  stars.forEach(s => {
    const dx = player.x - (s.x + s.size / 2);
    const dy = player.y - (s.y + s.size / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < player.radius + s.size / 2) {
      gameOver = true;
    }
  });
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw platforms
  ctx.fillStyle = '#00ffaa';
  platforms.forEach(p => {
    ctx.fillRect(p.x, p.y, p.width, p.height);
  });

  // Draw stars (real shape)
  stars.forEach(s => {
    drawStar(ctx, s.x + s.size / 2, s.y + s.size / 2, s.size / 2, 5, s.size / 4, 'yellow');
  });

  // Draw player
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
  ctx.fill();

  if (gameOver) {
    ctx.fillStyle = '#fff';
    ctx.font = '36px sans-serif';
    ctx.fillText('Game Over!', canvas.width / 2 - 100, canvas.height / 2);
    ctx.font = '18px sans-serif';
    ctx.fillText('Press R to Restart', canvas.width / 2 - 80, canvas.height / 2 + 30);
  }
}

// Function to draw a real 5-pointed star
function drawStar(ctx, cx, cy, outerRadius, points, innerRadius, color) {
  let angle = Math.PI / points;
  ctx.beginPath();
  ctx.moveTo(cx, cy - outerRadius);

  for (let i = 0; i < points * 2; i++) {
    let r = i % 2 === 0 ? outerRadius : innerRadius;
    let a = i * angle - Math.PI / 2;
    ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
  }

  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
}

function gameLoop() {
  update();
  draw();
  if (!gameOver) requestAnimationFrame(gameLoop);
}

function resetGame() {
  player.x = 400;
  player.y = 500;
  player.vy = -12;
  player.jumpCount = 0;
  score = 0;
  gameOver = false;
  stars = [];

  platforms = [];
  for (let i = 0; i < 20; i++) {
    platforms.push({
      x: Math.random() * (canvas.width - platformWidth),
      y: canvas.height - i * ladderGap,
      width: platformWidth,
      height: platformHeight,
      scored: false
    });
  }

  document.getElementById('scoreBoard').innerText = `Score: ${score}`;
  gameLoop();
}

// Start
gameLoop();
</script>

</body>
</html>
